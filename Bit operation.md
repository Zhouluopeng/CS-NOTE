#位操作
##抛砖引玉
企业笔试题常见套路：
交换两个整数，不能使用第三个变量
```c
//正常操作
int main(){
    int a=10;
    int b=20;
    int temp;
    temp=a;
    a=b;
    b=temp;
    printf("a=%d,b=%d\n",a,b);
    exit(0);
}
```
数学解法
```c
int main(){
    int a=10;
    int b=20;
    a=a+b;//有可能溢出
    b=a-b;
    a=a-b;
    printf("a=%d,b=%d\n",a,b);
    exit(0);
    //这个解决方案有一个问题，就是当a和b的值很大的时候，a+b的值可能会溢出
}
```
使用异或运算
```c
int main(){
    int a=10;
    int b=20;
    a=a^b;
    b=a^b;
    a=a^b;
    printf("a=%d,b=%d\n",a,b);
    exit(0);
    //位运算的解决方案，不会溢出
}
```
##位操作快速入门
###进制介绍
对于整数，我们常见的表示方法是十进制，二进制，八进制，十六进制
####十进制
十进制是我们最常见的进制，它是以10为基数的，它的每一位上的数字都是0-9，例如：1234，它的每一位上的数字分别是1，2，3，4，它的值是1*10^3+2*10^2+3*10^1+4*10^0=1234
####二进制
二进制是以2为基数的，它的每一位上的数字都是0-1，例如：1011，它的每一位上的数字分别是1，0，1，1，它的值是1*2^3+0*2^2+1*2^1+1*2^0=11
####八进制
八进制是以8为基数的，它的每一位上的数字都是0-7，例如：1234，它的每一位上的数字分别是1，2，3，4，它的值是1*8^3+2*8^2+3*8^1+4*8^0=668
####十六进制
十六进制是以16为基数的，它的每一位上的数字都是0-9，A-F，例如：1234，它的每一位上的数字分别是1，2，3，4，它的值是1*16^3+2*16^2+3*16^1+4*16^0=4660
```c
int main(){
    int n1=0b1011;//二进制
    int n2=01234;//八进制
    int n3=0x1234;//十六进制
    int n4=1234;//十进制
    printf("n1=%d,n2=%d,n3=%d,n4=%d\n",n1,n2,n3,n4);
    exit(0);
    //
}
```
####表格
|十进制|二进制|八进制|十六进制|
|:---:|:---:|:---:|:---:|
|0|0b0|00|0x0|
|1|0b1|01|0x1|
|2|0b10|02|0x2|
|3|0b11|03|0x3|
|4|0b100|04|0x4|
|5|0b101|05|0x5|
|6|0b110|06|0x6|
|7|0b111|07|0x7|
|8|0b1000|010|0x8|
|9|0b1001|011|0x9|
|10|0b1010|012|0xa|
|11|0b1011|013|0xb|
|12|0b1100|014|0xc|
|13|0b1101|015|0xd|
|14|0b1110|016|0xe|
|15|0b1111|017|0xf|
|16|0b10000|020|0x10|
####进制转换
#####二进制转十进制
0b1011=1*2的(1-1)次方+0*2的(2-1)次方+1*2的(3-1)次方+1*2的(4-1)次方=1+0+2+8=11
#####八进制转十进制
0234=4*8的(1-1)次方+3*8的(2-1)次方+2*8的(3-1)次方+0*8的(4-1)次方=4+24+128=156
#####十六进制转十进制
0x1234=4*16的(1-1)次方+3*16的(2-1)次方+2*16的(3-1)次方+1*16的(4-1)次方=4+48+512+4096=4660
#####十进制转二进制
11=1*2^3+0*2^2+1*2^1+1*2^0=0b1011
#####十进制转八进制
156=1*8^2+9*8^1+4*8^0=0234
#####十进制转十六进制
4660=1*16^3+2*16^2+3*16^1+4*16^0=0x1234
#####二进制转八进制
0b1011=1*2^3+0*2^2+1*2^1+1*2^0=0234
#####二进制转十六进制
0b1011=1*2^3+0*2^2+1*2^1+1*2^0=0x1234
#####八进制转二进制
0234=4*8^1+3*8^0=0b1011
#####八进制转十六进制
0234=4*8^1+3*8^0=0x1234
#####十六进制转二进制
0x1234=4*16^1+3*16^0=0b1011
#####十六进制转八进制
0x1234=4*16^1+3*16^0=0234
###原码、反码、补码
####原码
在计算机中所有的数字都是以二进制的形式存储的，原码就是二进制的原始形式，最高位是符号位，0表示正数，1表示负数，其余位表示数值部分 但是原码有一个缺点，就是加减法运算比较麻烦
比如：计算1+（-1）=0001+1001 计算机中的加法器是不区分正负数的，所以计算结果是1010，但是1010在原码中表示的是-2，所以计算结果是错误的 于是就有了反码
####反码
反码的规则是：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余位取反
再来计算一次1+（-1）=0001+1001 计算机中的加法器是不区分正负数的，所以计算结果是1010，1010在反码中表示的是-1，所以计算结果是正确的 但是反码也有一个缺点，就是0有两个表示形式，+0和-0，这样也不合理，会造成混乱，于是就有了补码
####补码
补码的规则是：正数的补码是其本身，负数的补码是在其原码的基础上，符号位不变，其余位取反，然后再加1
再来计算一次1+（-1）=0001+1111+1 计算机中的加法器是不区分正负数的，所以计算结果是（1）0000，（1）0000在补码中表示的是0，所以计算结果是正确的
####总结
正数的原码、反码、补码都是一样的(三码合一)
负数的反码是在其原码的基础上，符号位不变，其余位取反(0->1,1->0);
负数的补码是在其原码的基础上，符号位不变，其余位取反，然后再加1
0的反码和补码都是0
**计算机中所有的数字都是以补码的形式存储的**
###位操作
####位操作符
|操作符|含义|
|:---:|:---:|
|&|按位与|
|\||按位或|
|^|按位异或|
|~|按位取反|
|<<|左移|
|>>|右移|
####按位与
按位与的规则是：两个数的二进制位，同一位上的数字都是1，结果才是1，否则就是0
```c
int main(){
    int a=2;
    int b=3;
    int c=a&b;
    printf("c=%d\n",c);
    exit(0);
    //c=2
    //2的二进制是10，3的二进制是11，按位与的结果是10，转换成十进制就是2
}
```
####按位或
按位或的规则是：两个数的二进制位，同一位上的数字只要有一个是1，结果就是1，否则就是0
```c
int main(){
    int a=2;
    int b=3;
    int c=a|b;
    printf("c=%d\n",c);
    exit(0);
    //c=3
    //2的二进制是10，3的二进制是11，按位或的结果是11，转换成十进制就是3
}
```
####按位异或
按位异或的规则是：两个数的二进制位，同一位上的数字不同，结果就是1，否则就是0
```c
int main(){
    int a=2;
    int b=3;
    int c=a^b;
    printf("c=%d\n",c);
    exit(0);
    //c=1
    //2的二进制是10，3的二进制是11，按位异或的结果是01，转换成十进制就是1
}
```
####按位取反
按位取反的规则是：一个数的二进制位，0变1，1变0
```c
int main(){
    int a=2;
    int b=~a;
    printf("b=%d\n",b);
    exit(0);
    //b=-3
    //2的二进制是10，按位取反的结果是01，转换成十进制就是-3
}
```
####左移
左移的规则是：一个数的二进制位，向左移动n位，右边补0，相当于乘以2的n次方
```c
int main(){
    int a=2;
    int b=a<<2;
    printf("b=%d\n",b);
    exit(0);
    //b=8
    //2的二进制是10，左移两位的结果是1000，转换成十进制就是8
}
```
####右移
右移的规则是：一个数的二进制位，向右移动n位，左边补0，相当于除以2的n次方
```c
int main(){
    int a=2;
    int b=a>>2;
    printf("b=%d\n",b);
    exit(0);
    //b=0
    //2的二进制是10，右移两位的结果是0，转换成十进制就是0
}
```
###位操作应用
####判断奇偶
```c
int main(){
    int a=0b1011;
    if(a&1){
        printf("奇数\n");
    }else{
        printf("偶数\n");
    }
    exit(0);
    //奇数
}
```
####交换两个数
```c
int main(){
    int a=0b1011;
    int b=0b1100;
    a=a^b;
    b=a^b;
    a=a^b;
    printf("a=%d,b=%d\n",a,b);
    exit(0);
    //a=12,b=11
}
```
####取绝对值
```c
int main(){
    int a=-10;
    int b=a>>31;
    a=(a^b)-b;
    printf("a=%d\n",a);
    exit(0);
    //a=10
}
```
####取两个数的最大值
```c
int main(){
    int a=10;
    int b=20;
    int c=a-b;
    int d=c>>31;
    int e=(c^d)-d;
    printf("e=%d\n",e);
    exit(0);
    //e=20
}
```
####取两个数的最小值
```c
int main(){
    int a=10;
    int b=20;
    int c=a-b;
    int d=c>>31;
    int e=(c^d)-d;
    printf("e=%d\n",e);
    exit(0);
    //e=10
}
```
####判断符号是否相同
```c
int main(){
    int a=10;
    int b=-20;
    int c=a^b;
    int d=c>>31;
    if(d==0){
        printf("符号相同\n");
    }else{
        printf("符号不同\n");
    }
    exit(0);
    //符号不同
}
```
####求平均值
```c
int main(){
    int a=10;
    int b=20;
    int c=(a+b)>>1;
    printf("c=%d\n",c);
    exit(0);
    //c=15
}
```
####求绝对值
```c
int main(){
    int a=-10;
    int b=a>>31;
    a=(a^b)-b;
    printf("a=%d\n",a);
    exit(0);
    //a=10
}
```
###为什么要用位操作？
位操作的效率比较高，因为计算机底层就是用二进制来存储数据的，位操作就是直接对二进制进行操作，所以效率比较高
